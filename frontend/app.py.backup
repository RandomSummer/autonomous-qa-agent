"""
Streamlit Frontend for Autonomous QA Agent
User-friendly interface for the entire workflow.
"""

import streamlit as st
import requests
from pathlib import Path
import json
from typing import List, Dict

# Configure page
st.set_page_config(
    page_title="Autonomous QA Agent",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# API Base URL - FastAPI backend
API_BASE = "http://localhost:8000"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def call_api(endpoint: str, method: str = "GET", **kwargs):
    """
    Make API call to FastAPI backend.
    Handles errors and returns JSON response.
    """
    url = f"{API_BASE}{endpoint}"
    
    try:
        if method == "GET":
            response = requests.get(url, **kwargs)
        elif method == "POST":
            response = requests.post(url, **kwargs)
        elif method == "DELETE":
            response = requests.delete(url, **kwargs)
        
        response.raise_for_status()
        return response.json()
    
    except requests.exceptions.ConnectionError:
        st.error("‚ùå Cannot connect to API. Make sure FastAPI server is running on port 8000")
        st.code("uvicorn backend.main:app --reload --port 8000")
        return None
    
    except requests.exceptions.HTTPError as e:
        st.error(f"‚ùå API Error: {e.response.text}")
        return None
    
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")
        return None


def upload_files_to_api(files, endpoint: str):
    """
    Upload multiple files to API endpoint.
    """
    file_data = []
    
    for file in files:
        file_data.append(
            ("files", (file.name, file, file.type))
        )
    
    try:
        response = requests.post(
            f"{API_BASE}{endpoint}",
            files=file_data
        )
        response.raise_for_status()
        return response.json()
    
    except Exception as e:
        st.error(f"Upload error: {str(e)}")
        return None
        "Choose a step:",
        ["1Ô∏è‚É£ Upload Documents", "2Ô∏è‚É£ Build Knowledge Base", "3Ô∏è‚É£ Generate Test Cases", "4Ô∏è‚É£ Generate Scripts"]
    )
    
    # ========================================================================
    # PAGE 1: UPLOAD DOCUMENTS
    # ========================================================================
    
    if page == "1Ô∏è‚É£ Upload Documents":
        st.header("üì§ Upload Documents")
        
        st.markdown("""
        Upload your project documentation files:
        - **Support Docs**: Product specs, UI guides, API docs (MD, TXT, JSON, PDF)
        - **HTML File**: Your checkout.html or target web page
        """)
        
        # Upload support documents
        st.subheader("üìÑ Support Documents")
        support_files = st.file_uploader(
            "Upload support documents",
            type=["md", "txt", "json", "pdf"],
            accept_multiple_files=True,
            help="Upload 3-5 documentation files"
        )
        
        if support_files:
            if st.button("Upload Support Documents", type="primary"):
                with st.spinner("Uploading..."):
                    result = upload_files_to_api(support_files, "/api/upload/documents")
                    
                    if result:
                        for res in result:
                            if res['success']:
                                st.success(f"‚úÖ {res['filename']}")
                            else:
                                st.error(f"‚ùå {res['filename']}: {res['message']}")
        
        # Upload HTML file
        st.subheader("üåê HTML File")
        html_file = st.file_uploader(
            "Upload checkout.html",
            type=["html", "htm"],
            help="The target web page for testing"
        )
        
        if html_file:
            if st.button("Upload HTML File", type="primary"):
                with st.spinner("Uploading..."):
                    files = [("file", (html_file.name, html_file, html_file.type))]
                    try:
                        response = requests.post(f"{API_BASE}/api/upload/html", files=files)
                        response.raise_for_status()
                        result = response.json()
                        st.success(f"‚úÖ {result['filename']} uploaded successfully!")
                    except Exception as e:
                        st.error(f"Upload error: {str(e)}")
        
        # Show uploaded files
        st.divider()
        st.subheader("üìÇ Uploaded Files")
        
        if st.button("Refresh File List"):
            uploads = call_api("/api/uploads/list")
            if uploads:
                st.write(f"**Total Files:** {uploads['total']}")
                for file in uploads['files']:
                    st.text(f"üìÑ {file}")
        
        # Clear uploads
        if st.button("üóëÔ∏è Clear All Uploads", help="Delete all uploaded files"):
            if st.warning("Are you sure? This cannot be undone."):
                result = call_api("/api/uploads/clear", method="DELETE")
                if result:
                    st.success(result['message'])
                    st.rerun()
    
    # ========================================================================
    # PAGE 2: BUILD KNOWLEDGE BASE
    # ========================================================================
    
    elif page == "2Ô∏è‚É£ Build Knowledge Base":
        st.header("üß† Build Knowledge Base")
        
        st.markdown("""
        Process uploaded documents and build vector database for RAG retrieval.
        
        **This step:**
        1. Parses all uploaded documents
        2. Splits into chunks
        3. Generates embeddings
        4. Stores in ChromaDB
        """)
        
        # Show current stats
        stats = call_api("/api/knowledge-base/stats")
        if stats:
            col1, col2 = st.columns(2)
            with col1:
                st.metric("Total Documents", stats['total_documents'])
            with col2:
                st.metric("Total Chunks", stats['total_chunks'])
            
            if stats['documents']:
                st.write("**Documents in Knowledge Base:**")
                for doc in stats['documents']:
                    st.text(f"üìÑ {doc}")
        
        st.divider()
        
        # Build options
        col1, col2 = st.columns([1, 3])
        with col1:
            clear_existing = st.checkbox("Clear existing data", value=False)
        
        # Build button
        if st.button("üöÄ Build Knowledge Base", type="primary", use_container_width=True):
            with st.spinner("Building knowledge base... This may take a minute."):
                result = call_api(
                    f"/api/knowledge-base/build?clear_existing={clear_existing}",
                    method="POST"
                )
                
                if result:
                    if result['success']:
                        st.success("‚úÖ Knowledge base built successfully!")
                        st.metric("Documents Processed", result['total_documents'])
                        st.metric("Total Chunks", result['total_chunks'])
                        
                        st.write("**Processed Documents:**")
                        for doc in result['documents_processed']:
                            st.text(f"‚úì {doc}")
                    else:
                        st.error(f"‚ùå Failed: {result['message']}")
    
    # ========================================================================
    # PAGE 3: GENERATE TEST CASES
    # ========================================================================
    
    elif page == "3Ô∏è‚É£ Generate Test Cases":
        st.header("üß™ Generate Test Cases")
        
        st.markdown("""
        Generate documentation-grounded test cases using AI.
        
        **How it works:**
        1. Enter what you want to test
        2. AI retrieves relevant documentation
        3. Generates structured test cases
        4. All test cases reference source documents
        """)
        
        # Input form
        with st.form("test_case_form"):
            query = st.text_area(
                "What do you want to test?",
                placeholder="Example: Generate test cases for discount code validation",
                height=100,
                help="Be specific about the feature or scenario"
            )
            
            include_negative = st.checkbox("Include negative test cases", value=True)
            
            submitted = st.form_submit_button("üöÄ Generate Test Cases", type="primary")
        
        if submitted and query:
            with st.spinner("Generating test cases... Using RAG to retrieve context..."):
                result = call_api(
                    "/api/test-cases/generate",
                    method="POST",
                    json={
                        "query": query,
                        "include_negative": include_negative
                    }
                )
                
                if result:
                    if result['success']:
                        st.success(f"‚úÖ Generated {result['total_cases']} test cases!")
                        
                        # Store in session state for script generation
                        st.session_state['test_cases'] = result['test_cases']
                        st.session_state['html_available'] = True
                        
                        # Display test cases
                        for i, tc in enumerate(result['test_cases']):
                            with st.expander(f"**{tc['test_id']}: {tc['feature']}** ({tc['test_type']})", expanded=i==0):
                                st.write(f"**Scenario:** {tc['test_scenario']}")
                                st.write(f"**Type:** {tc['test_type']}")
                                
                                if tc.get('preconditions'):
                                    st.write(f"**Preconditions:** {tc['preconditions']}")
                                
                                st.write("**Test Steps:**")
                                for j, step in enumerate(tc['test_steps'], 1):
                                    st.write(f"{j}. {step}")
                                
                                st.write(f"**Expected Result:** {tc['expected_result']}")
                                
                                st.info(f"üìö **Grounded in:** {tc['grounded_in']}")
                                
                                # Copy as JSON
                                if st.button(f"üìã Copy JSON", key=f"copy_{tc['test_id']}"):
                                    st.code(json.dumps(tc, indent=2), language="json")
                    else:
                        st.error(f"‚ùå Failed: {result['message']}")
    
    # ========================================================================
    # PAGE 4: GENERATE SCRIPTS
    # ========================================================================
    
    elif page == "4Ô∏è‚É£ Generate Scripts":
        st.header("üêç Generate Selenium Scripts")
        
        st.markdown("""
        Convert test cases into executable Python Selenium scripts.
        
        **Requirements:**
        1. Test cases generated (from previous step)
        2. HTML file uploaded
        """)
        
        # Check if test cases exist in session
        if 'test_cases' not in st.session_state or not st.session_state['test_cases']:
            st.warning("‚ö†Ô∏è No test cases found. Please generate test cases first (Step 3).")
            st.info("üëà Go to **3Ô∏è‚É£ Generate Test Cases** to create test cases.")
        else:
            test_cases = st.session_state['test_cases']
            st.success(f"‚úÖ {len(test_cases)} test cases available")
            
            # Select test case
            st.subheader("Select Test Case")
            
            test_case_options = [
                f"{tc['test_id']}: {tc['feature']} - {tc['test_scenario']}"
                for tc in test_cases
            ]
            
            selected_idx = st.selectbox(
                "Choose a test case to convert:",
                range(len(test_case_options)),
                format_func=lambda x: test_case_options[x]
            )
            
            selected_test_case = test_cases[selected_idx]
            
            # Show selected test case
            with st.expander("üìã Selected Test Case Details", expanded=True):
                st.write(f"**Test ID:** {selected_test_case['test_id']}")
                st.write(f"**Feature:** {selected_test_case['feature']}")
                st.write(f"**Scenario:** {selected_test_case['test_scenario']}")
                st.write(f"**Expected:** {selected_test_case['expected_result']}")
            
            # Load HTML content
            st.subheader("HTML Content")
            
            # Try to load from uploads
            html_path = Path("data/uploads/checkout.html")
            
            if html_path.exists():
                with open(html_path, 'r', encoding='utf-8') as f:
                    html_content = f.read()
                st.success(f"‚úÖ HTML loaded: {len(html_content)} characters")
            else:
                st.warning("‚ö†Ô∏è No HTML file found. Please upload checkout.html in Step 1.")
                html_content = st.text_area(
                    "Or paste HTML content here:",
                    height=200,
                    placeholder="<html>...</html>"
                )
            
            # Generate button
            if st.button("üöÄ Generate Selenium Script", type="primary", use_container_width=True):
                if not html_content:
                    st.error("‚ùå HTML content is required")
                else:
                    with st.spinner("Generating Selenium script... Analyzing HTML and creating code..."):
                        result = call_api(
                            "/api/scripts/generate",
                            method="POST",
                            json={
                                "test_case": selected_test_case,
                                "html_content": html_content
                            }
                        )
                        
                        if result:
                            if result['success']:
                                st.success("‚úÖ Script generated successfully!")
                                
                                script = result['script']
                                
                                # Display script
                                st.subheader(f"üìÑ {script['filename']}")
                                st.code(script['script_content'], language="python")
                                
                                # Download button
                                st.download_button(
                                    label="üíæ Download Script",
                                    data=script['script_content'],
                                    file_name=script['filename'],
                                    mime="text/x-python"
                                )
                                
                                # Show dependencies
                                st.info(f"**Dependencies:** {', '.join(script['dependencies'])}")
                                
                                # How to run
                                with st.expander("üöÄ How to Run This Script"):
                                    st.markdown("""
                                    **1. Install dependencies:**
                                    ```bash
                                    pip install selenium webdriver-manager
                                    ```
                                    
                                    **2. Update file path in script:**
                                    - Change `file:///path/to/checkout.html` to your actual HTML file path
                                    
                                    **3. Run the script:**
                                    ```bash
                                    python test_tc_001.py
                                    ```
                                    """)
                            else:
                                st.error(f"‚ùå Failed: {result['message']}")
        
        # List generated scripts
        st.divider()
        st.subheader("üìÇ Generated Scripts")
        
        scripts = call_api("/api/scripts/list")
        if scripts:
            st.write(f"**Total Scripts:** {scripts['total']}")
            
            if scripts['scripts']:
                for script_name in scripts['scripts']:
                    col1, col2 = st.columns([3, 1])
                    with col1:
                        st.text(f"üêç {script_name}")
                    with col2:
                        # Download link
                        st.link_button(
                            "‚¨áÔ∏è Download",
                            f"{API_BASE}/api/scripts/download/{script_name}"
                        )


# Sidebar info
st.sidebar.divider()
st.sidebar.markdown("""
### üìö Help

**Step 1:** Upload 3-5 docs + HTML  
**Step 2:** Build vector database  
**Step 3:** Generate test cases  
**Step 4:** Create Selenium scripts  

---

**Need help?**
- Check FastAPI is running
- Verify Groq API key in .env
- Review uploaded documents
""")

# Run the app
if __name__ == "__main__":
    main()